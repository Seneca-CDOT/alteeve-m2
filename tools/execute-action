#!/usr/bin/perl

use strict;
use warnings;
use AN::Tools;
no warnings 'recursion';

# Disable buffering.
$| = 1;

my $THIS_FILE = ($0 =~ /^.*\/(.*)$/)[0];
my $N_HOSTS = 2;
my $N_ACTIONS = 4;

my $an = AN::Tools->new({
	data => {
		path => {
			striker_config => "/etc/striker/striker.conf",
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

$an->Get->switches();

if (not $an->data->{switches}{action})
{
	print "Missing action number."."\n";

	$an->nice_exit({exit_code => 1});
}

if (not $an->data->{switches}{node})
{
	print "Missing node number."."\n";

	$an->nice_exit({exit_code => 1});
}

if (not $an->data->{switches}{csv})
{
	print "Missing action CSV."."\n";

	$an->nice_exit({exit_code => 1});
}

sub print_hash
{
	my $parameter = shift;

	if ($parameter->{print_hash_message_prefix})
	{
		print $parameter->{print_hash_message_prefix}."\n";

		delete $parameter->{print_hash_message_prefix};
	}

	foreach my $key (keys %{$parameter})
	{
		my $value = $parameter->{$key} ? $parameter->{$key} : "";

		print "$key: [$value]"."\n";
	}
}

sub get_node_uuid
{
	my $parameter = shift;

	if (not $parameter->{node_number})
	{
		return;
	}

	my $get_node_uuid_query = '
SELECT nodes.node_uuid
FROM public.hosts hosts
INNER JOIN public.nodes nodes
	ON hosts.host_uuid = nodes.node_host_uuid
WHERE hosts.host_name LIKE \'an-a%n%'.$parameter->{node_number}.'%\';
	';

	print_hash({
		get_node_uuid_query	=>	$get_node_uuid_query,
	});

	my $node_uuid = $an->DB->do_db_query({
		query	=>	$get_node_uuid_query,
		source	=>	$THIS_FILE,
		line	=>	__LINE__
	})->[0]->[0];

	print_hash({
		node_uuid	=>	$node_uuid,
	});

	return $node_uuid;
}

my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});

my $node_uuid = get_node_uuid({
	node_number	=>	$an->data->{switches}{node},
});

print_hash({
	action		=>	$an->data->{switches}{action},
	node_uuid	=>	$node_uuid,
	csv 		=>	$an->data->{switches}{csv},
});

my @action_array = split(",", $an->data->{switches}{csv});

my $record_action_query = "
INSERT INTO
	history.actions
(
	uuid,
	host_uuid,
	".join(",",
		map {
			my $node_prefix = "node_".$_."_";
			map { $node_prefix."action_".$_ } 1..$N_ACTIONS
		} 1..$N_HOSTS
	).",
	modified_date
) VALUES (
	".$an->data->{sys}{use_db_fh}->quote($an->Get->uuid()).",
	".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
	".join(",",
		map { $an->data->{sys}{use_db_fh}->quote($_) } @action_array
	).",
	".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";

print_hash({
	record_action_query	=>	$record_action_query,
});

$an->DB->do_db_write({
	query	=>	$record_action_query,
	source	=>	$THIS_FILE,
	line	=>	__LINE__
});

# Only executed when host is a Node.
#
# Migrate all servers to this Node.
if ($an->data->{switches}{action} == 2)
{
	$an->Striker->load_anvil({anvil_uuid => $an->data->{sys}{anvil_uuid}});

	my $node_name = $an->hostname;
	my $peer_key  = $an->data->{sys}{node_name}{$node_name}{peer_node_key};
	my $peer_name = $an->data->{sys}{anvil}{$peer_key}{name};

	print_hash({
		node_name	=>	$node_name,
		peer_key	=>	$peer_key,
		peer_name	=>	$peer_name,
	});

	my $shell_call = $an->data->{path}{clustat};

	print_hash({
		shell_call	=>	$shell_call,
	});

	if (open (my $clustat_out_file_handle, $shell_call." 2>&1 |"))
	{
		while(<$clustat_out_file_handle>)
		{
			chomp;

			my $line =  $_;

			$line =~ s/\s+/ /g;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;

			print_hash({
				line	=>	$line,
			});

			if ($line =~ /^vm:(.*?) (.*?) (.*)/)
			{
				my $server = $1;
				my $host   = $2;
				my $state  = $3;

				print_hash({
					server	=>	$server,
					host	=>	$host,
					state	=>	$state,
				});

				if (($host eq $peer_name) && ($state eq "started"))
				{
					my $shell_call = $an->data->{path}{'anvil-migrate-server'}." --server $server; ".$an->data->{path}{'echo'}." return_code:\$?";

					print_hash({
						shell_call	=>	$shell_call,
					});

					if (open (my $anvil_migrate_server_out_file_handle, $shell_call." 2>&1 |"))
					{
						while(<$anvil_migrate_server_out_file_handle>)
						{
							chomp;

							my $line = $_;

							print_hash({
								line	=>	$line,
							});

							if ($line =~ /return_code:(\d+)$/)
							{
								my $return = $1;

								print_hash({
									return	=>	$return,
								});
							}
						}

						close $anvil_migrate_server_out_file_handle;
					}
					else
					{
						print_hash({
							print_hash_message_prefix	=>	"Failed to call:",
							shell_call					=>	$shell_call,
							error						=>	$!,
						});

						$an->nice_exit({exit_code => 2});
					}
				}
			}
		}

		close $clustat_out_file_handle;
	}
	else
	{
		print_hash({
			print_hash_message_prefix	=>	"Failed to call:",
			shell_call					=>	$shell_call,
			error						=>	$!,
		});

		$an->nice_exit({exit_code => 2});
	}
}
# Only executed when host is a Node.
#
# Shut down this Node.
elsif ($an->data->{switches}{action} == 3)
{
	my $shell_call = $an->data->{path}{'anvil-safe-stop'}." --local --suicide";

	print_hash({
		shell_call	=>	$shell_call,
	});

	if (open(my $anvil_safe_stop_out_file_handle, "$shell_call 2>&1 |"))
	{
		while (<$anvil_safe_stop_out_file_handle>)
		{
			chomp;

			my $line = $_;

			$line =~ s/\n//g;
			$line =~ s/\r//g;

			print_hash({
				line	=>	$line,
			});
		}

		close $anvil_safe_stop_out_file_handle;
	}
	else
	{
		print_hash({
			print_hash_message_prefix	=>	"Failed to call:",
			shell_call					=>	$shell_call,
			error						=>	$!,
		});

		$an->nice_exit({exit_code => 2});
	}
}
# Only executed when host is a Striker.
#
# Boot the Node specified by the node flag.
elsif ($an->data->{switches}{action} == 4)
{
	my $state = $an->ScanCore->target_power({
		target	=> $node_uuid,
		task	=> "on",
	});

	print_hash({
		state	=>	$state,
	});
}
